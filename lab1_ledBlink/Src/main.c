/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
#include "stm32f0xx.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//uint8_t SOS_sequence_array[32] = {1,0,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,0};
	    					//      S             O                         S          fill 32 bit
uint32_t SOS_sequence = 0b10101001110111011100101010000000;// SOS in uint32_t starting at MSB and filled with zeros to LSB


int main(void)
{
  RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
  GPIOA->MODER |= GPIO_MODER_MODER5_0;


    /* Loop forever */
	//for(;;); // i prefer while loop....
while(1)
	{
	/*	//first option:
	 	//in each step compare 32-i
		for (uint32_t i = 0; i < 32; i++)
		{
		  if (SOS_sequence & (1<<(31-i))){ //starts with i = 0 -> MSB if MSB and 0b10000(32 zeros)
			  GPIOA->BSRR = (1<<5); //shift 1 into BSRR (SET ON)
		  }
		  else{
			  GPIOA->BRR = (1<<5); //shift 1 into BSRR (RESET OFF)
		  }

		  for (volatile uint32_t i = 0;i< 100000;i++){} //delay (basicaly wait until uC increment i 100000 times)
		}
		*/

		//second option:
		//in each step compare MSB with SOS_sequence and shift sequence left by 1
		uint32_t SOS_sequence = 0b10101001110111011100101010000000;
		for (uint32_t i = 0; i < 32; i++)
		{
		  if (SOS_sequence & 0x80){ //0x80 = 0b1(31 zeros)
			  GPIOA->BSRR = (1<<5); //shift 1 into BSRR (SET ON)
		  }
		  else{
			  GPIOA->BRR = (1<<5); //shift 1 into BSRR (RESET OFF)
		  }

		  for (volatile uint32_t i = 0;i< 100000;i++){} //delay (basicaly wait until uC increment i 100000 times)
		  SOS_sequence = (SOS_sequence << 1);
		}
	}
}
